mod display;
mod dns;
mod http;
mod platform;
mod touch;
mod wifi;

use std::cell::RefCell;
use std::sync::{Arc, Mutex};

use esp_idf_hal::ledc::{config::TimerConfig, LedcDriver, LedcTimerDriver};
use esp_idf_hal::peripherals::Peripherals;
use esp_idf_hal::units::FromValueType;
use esp_idf_svc::eventloop::EspSystemEventLoop;
use esp_idf_svc::nvs::EspDefaultNvsPartition;
use esp_idf_sys as _;
use slint::{Image, Rgb8Pixel, SharedPixelBuffer};

use crate::display::DisplayLineBuffer;
use crate::platform::Esp32Platform;
use crate::touch::TouchController;

// Generated by slint-build from ui/badge.slint
slint::include_modules!();

fn main() -> anyhow::Result<()> {
    // Initialize ESP-IDF logging + system
    esp_idf_svc::log::EspLogger::initialize_default();
    log::info!("VRCBadge firmware starting");

    // Take hardware peripherals
    let peripherals = Peripherals::take()?;

    // --- WiFi AP + HTTP server ---
    let sys_loop = EspSystemEventLoop::take()?;
    let nvs_partition = EspDefaultNvsPartition::take()?;
    let (_wifi, ap_ip) = wifi::init(peripherals.modem, sys_loop, nvs_partition)?;
    dns::start(ap_ip)?;
    let pending_background: http::SharedImageData = Arc::new(Mutex::new(None));
    let _server = http::init(ap_ip, pending_background.clone())?;

    // --- Slint platform ---
    let esp_platform = Esp32Platform::new();
    let window = esp_platform.window();
    slint::platform::set_platform(Box::new(esp_platform))
        .map_err(|e| anyhow::anyhow!("Failed to set Slint platform: {:?}", e))?;

    // --- Display (ST7796S over SPI) ---
    let mut display = display::init(
        peripherals.spi2,
        peripherals.pins.gpio12.into(), // SCLK
        peripherals.pins.gpio11.into(), // MOSI
        peripherals.pins.gpio10.into(), // CS
        peripherals.pins.gpio9.into(),  // DC
        peripherals.pins.gpio8.into(),  // RST
    )?;

    // --- Backlight PWM (25kHz, 8-bit = 256 duty levels) ---
    let timer = LedcTimerDriver::new(
        peripherals.ledc.timer0,
        &TimerConfig::new()
            .frequency(25.kHz().into())
            .resolution(esp_idf_hal::ledc::Resolution::Bits8),
    )?;
    let mut backlight = LedcDriver::new(peripherals.ledc.channel0, timer, peripherals.pins.gpio7)?;
    let max_duty = backlight.get_max_duty();
    backlight.set_duty(max_duty / 2)?; // Start at 50% brightness

    // --- Touch (GT911 over I2C) ---
    let mut touch = match TouchController::new(
        peripherals.i2c0,
        peripherals.pins.gpio1.into(), // SDA
        peripherals.pins.gpio2.into(), // SCL
        peripherals.pins.gpio4.into(), // Touch RST
        peripherals.pins.gpio3.into(), // Touch INT
    ) {
        Ok(t) => Some(t),
        Err(e) => {
            log::warn!("Touch init failed (display/WiFi still active): {e}");
            None
        }
    };

    // --- Create UI ---
    let ui = BadgeUI::new().map_err(|e| anyhow::anyhow!("Failed to create UI: {:?}", e))?;

    // Set initial values
    ui.set_display_name("Hebu".into());
    ui.set_tagline("Hello from VRCBadge!".into());
    ui.set_twitter_handle("@Hebu_VRC".into());
    ui.set_discord_handle("hebu".into());
    ui.set_battery_percent(100);
    ui.set_wifi_ip(ap_ip.to_string().into());

    // Wire brightness slider to backlight PWM (debounced to avoid flicker)
    let backlight = RefCell::new(backlight);
    let last_brightness = RefCell::new(50.0_f32);
    ui.on_brightness_changed(move |percent| {
        let clamped = percent.clamp(10.0, 100.0);
        let mut last = last_brightness.borrow_mut();
        if (clamped - *last).abs() >= 2.0 {
            *last = clamped;
            let duty = (clamped / 100.0 * max_duty as f32) as u32;
            let _ = backlight.borrow_mut().set_duty(duty);
        }
    });

    log::info!("UI initialized, entering main loop");

    // --- Main event loop ---
    let mut loop_count: u32 = 0;
    loop {
        // 1. Process Slint timers and animations
        slint::platform::update_timers_and_animations();

        // 2. Poll touch input → dispatch events to Slint
        if let Some(ref mut touch) = touch {
            touch.poll(&window);
        }

        // 3. Poll for updates (~every 2 seconds at 16ms sleep = 125 iterations)
        loop_count = loop_count.wrapping_add(1);
        if loop_count % 125 == 0 {
            // WiFi client count
            let clients = wifi::connected_clients() as i32;
            ui.set_wifi_clients(clients);

            // Check for new background image from HTTP upload
            if let Ok(mut pending) = pending_background.try_lock() {
                if let Some(rgb_data) = pending.take() {
                    let buffer = SharedPixelBuffer::<Rgb8Pixel>::clone_from_slice(
                        &rgb_data,
                        platform::DISPLAY_WIDTH,
                        platform::DISPLAY_HEIGHT,
                    );
                    ui.set_background_image(Image::from_rgb8(buffer));
                    log::info!("Background image updated");
                }
            }
        }

        // 4. Render display if needed
        window.draw_if_needed(|renderer| {
            renderer.render_by_line(DisplayLineBuffer::new(&mut display));
        });

        // 5. Sleep until next event needed
        if !window.has_active_animations() {
            if let Some(duration) = slint::platform::duration_until_next_timer_update() {
                // Sleep for at most the duration, but wake periodically for touch polling
                let sleep_ms = duration.as_millis().min(16) as u32; // Cap at ~60fps for touch
                esp_idf_hal::delay::FreeRtos::delay_ms(sleep_ms);
            } else {
                // No timers pending — sleep briefly for touch responsiveness
                esp_idf_hal::delay::FreeRtos::delay_ms(16);
            }
        }
    }
}
