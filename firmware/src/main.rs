mod display;
mod dns;
mod logger;
mod platform;
mod profile;
mod storage;
mod sysinfo;
mod touch;
mod web;
mod wifi;

use std::cell::RefCell;
use std::sync::{Arc, Mutex};
use std::time::Instant;

use esp_idf_hal::ledc::{config::TimerConfig, LedcDriver, LedcTimerDriver};
use esp_idf_hal::peripherals::Peripherals;
use esp_idf_hal::units::FromValueType;
use esp_idf_svc::eventloop::EspSystemEventLoop;
use esp_idf_svc::nvs::EspDefaultNvsPartition;
use esp_idf_sys as _;
use slint::{Image, Rgb8Pixel, SharedPixelBuffer};

use crate::platform::Esp32Platform;
use crate::touch::TouchController;

// Generated by slint-build from ui/badge.slint
slint::include_modules!();

fn main() -> anyhow::Result<()> {
    // Initialize dual logger (serial + ring buffer for About page)
    logger::init();
    let boot_time = Instant::now();
    log::info!("VRCBadge firmware starting");

    // Take hardware peripherals
    let peripherals = Peripherals::take()?;

    // --- Persistent storage (NVS + SPIFFS) ---
    let nvs_partition = EspDefaultNvsPartition::take()?;
    let nvs_for_storage = nvs_partition.clone(); // clone before WiFi consumes it
    let mut nvs = storage::init_nvs(nvs_for_storage)?;
    storage::init_spiffs()?;

    // --- WiFi AP + HTTP server ---
    let sys_loop = EspSystemEventLoop::take()?;
    let (_wifi, ap_ip) = wifi::init(peripherals.modem, sys_loop, nvs_partition)?;
    dns::start(ap_ip)?;
    let pending_background: web::SharedImageData = Arc::new(Mutex::new(None));
    let pending_avatar: web::SharedImageData = Arc::new(Mutex::new(None));
    let saved_profile = storage::load_profile(&nvs).unwrap_or_default();
    let current_profile: profile::CurrentProfile = Arc::new(Mutex::new(saved_profile.clone()));
    let pending_profile: profile::PendingProfile = Arc::new(Mutex::new(None));
    let _server = web::init(
        ap_ip,
        pending_background.clone(),
        pending_avatar.clone(),
        current_profile.clone(),
        pending_profile.clone(),
    )?;

    // --- Slint platform ---
    let esp_platform = Esp32Platform::new();
    let window = esp_platform.window();
    slint::platform::set_platform(Box::new(esp_platform))
        .map_err(|e| anyhow::anyhow!("Failed to set Slint platform: {:?}", e))?;

    // --- Display (ST7796S over SPI) ---
    let mut display = display::init(
        peripherals.spi2,
        peripherals.pins.gpio12.into(), // SCLK
        peripherals.pins.gpio11.into(), // MOSI
        peripherals.pins.gpio10.into(), // CS
        peripherals.pins.gpio9.into(),  // DC
        peripherals.pins.gpio8.into(),  // RST
    )?;

    // --- Framebuffer (480x320 RGB565 in PSRAM) ---
    let framebuffer = display::allocate_framebuffer();

    // --- Backlight PWM (25kHz, 8-bit = 256 duty levels) ---
    let timer = LedcTimerDriver::new(
        peripherals.ledc.timer0,
        &TimerConfig::new()
            .frequency(25.kHz().into())
            .resolution(esp_idf_hal::ledc::Resolution::Bits8),
    )?;
    let mut backlight = LedcDriver::new(peripherals.ledc.channel0, timer, peripherals.pins.gpio7)?;
    let max_duty = backlight.get_max_duty();
    backlight.set_duty(max_duty / 2)?; // Start at 50% brightness

    // --- Touch (GT911 over I2C) ---
    let mut touch = match TouchController::new(
        peripherals.i2c0,
        peripherals.pins.gpio1.into(), // SDA
        peripherals.pins.gpio2.into(), // SCL
        peripherals.pins.gpio4.into(), // Touch RST
        peripherals.pins.gpio3.into(), // Touch INT
    ) {
        Ok(t) => Some(t),
        Err(e) => {
            log::warn!("Touch init failed (display/WiFi still active): {e}");
            None
        }
    };

    // --- Create UI ---
    let ui = BadgeUI::new().map_err(|e| anyhow::anyhow!("Failed to create UI: {:?}", e))?;

    // Set initial values from saved (or default) profile
    ui.set_display_name(saved_profile.display_name.into());
    ui.set_tagline(saved_profile.tagline.into());
    ui.set_twitter_handle(saved_profile.twitter_handle.into());
    ui.set_discord_handle(saved_profile.discord_handle.into());
    ui.set_battery_percent(100);
    ui.set_wifi_ip(ap_ip.to_string().into());
    ui.set_firmware_version(sysinfo::firmware_version().into());

    // Restore saved avatar from SPIFFS (67.5 KB)
    if let Some(rgb_data) = storage::load_image("avatar", storage::AVATAR_IMAGE_SIZE) {
        let buffer = SharedPixelBuffer::<Rgb8Pixel>::clone_from_slice(
            &rgb_data,
            storage::AVATAR_WIDTH,
            storage::AVATAR_HEIGHT,
        );
        ui.set_avatar_image(Image::from_rgb8(buffer));
    }

    // Restore saved background from SPIFFS (460 KB)
    if let Some(rgb_data) = storage::load_image("background", storage::BACKGROUND_IMAGE_SIZE) {
        let buffer = SharedPixelBuffer::<Rgb8Pixel>::clone_from_slice(
            &rgb_data,
            platform::DISPLAY_WIDTH,
            platform::DISPLAY_HEIGHT,
        );
        ui.set_background_image(Image::from_rgb8(buffer));
    }

    // Wire brightness slider to backlight PWM (debounced to avoid flicker)
    let backlight = RefCell::new(backlight);
    let last_brightness = RefCell::new(50.0_f32);
    ui.on_brightness_changed(move |percent| {
        let clamped = percent.clamp(10.0, 100.0);
        let mut last = last_brightness.borrow_mut();
        if (clamped - *last).abs() >= 2.0 {
            *last = clamped;
            let duty = (clamped / 100.0 * max_duty as f32) as u32;
            let _ = backlight.borrow_mut().set_duty(duty);
        }
    });

    log::info!("Boot complete, entering main loop");

    // --- Main event loop ---
    let mut loop_count: u32 = 0;
    loop {
        // 1. Process Slint timers and animations
        slint::platform::update_timers_and_animations();

        // 2. Poll touch input -> dispatch events to Slint
        if let Some(ref mut touch) = touch {
            touch.poll(&window);
        }

        // 3. Poll for updates (~every 2 seconds at 16ms sleep = 125 iterations)
        loop_count = loop_count.wrapping_add(1);
        if loop_count % 125 == 0 {
            // WiFi client count
            let clients = wifi::connected_clients() as i32;
            ui.set_wifi_clients(clients);

            // About page: system info + logs
            ui.set_about_uptime(sysinfo::uptime_string(&boot_time).into());
            ui.set_about_heap(format!("{} KB", sysinfo::free_heap_kb()).into());
            ui.set_about_psram(format!("{} KB", sysinfo::free_psram_kb()).into());
            ui.set_log_text(logger::snapshot().into());

            // Check for profile update from web
            if let Ok(mut pending) = pending_profile.try_lock() {
                if let Some(new_profile) = pending.take() {
                    ui.set_display_name(new_profile.display_name.clone().into());
                    ui.set_tagline(new_profile.tagline.clone().into());
                    ui.set_twitter_handle(new_profile.twitter_handle.clone().into());
                    ui.set_discord_handle(new_profile.discord_handle.clone().into());
                    // Update current profile for future GET /api/profile requests
                    if let Ok(mut current) = current_profile.try_lock() {
                        *current = new_profile.clone();
                    }
                    storage::save_profile(&mut nvs, &new_profile);
                    log::info!("Badge profile updated");
                }
            }

            // Check for new avatar image from HTTP upload
            if let Ok(mut pending) = pending_avatar.try_lock() {
                if let Some(rgb_data) = pending.take() {
                    let buffer = SharedPixelBuffer::<Rgb8Pixel>::clone_from_slice(
                        &rgb_data,
                        storage::AVATAR_WIDTH,
                        storage::AVATAR_HEIGHT,
                    );
                    ui.set_avatar_image(Image::from_rgb8(buffer));
                    storage::save_image("avatar", &rgb_data);
                    log::info!("Avatar image updated");
                }
            }

            // Check for new background image from HTTP upload
            if let Ok(mut pending) = pending_background.try_lock() {
                if let Some(rgb_data) = pending.take() {
                    let buffer = SharedPixelBuffer::<Rgb8Pixel>::clone_from_slice(
                        &rgb_data,
                        platform::DISPLAY_WIDTH,
                        platform::DISPLAY_HEIGHT,
                    );
                    ui.set_background_image(Image::from_rgb8(buffer));
                    storage::save_image("background", &rgb_data);
                    log::info!("Background image updated");
                }
            }
        }

        // 4. Render into framebuffer and send only dirty regions to display
        window.draw_if_needed(|renderer| {
            let region = renderer.render(framebuffer, platform::DISPLAY_WIDTH as usize);
            display::send_dirty_region(&mut display, framebuffer, region);
        });

        // 5. Sleep until next event needed
        if !window.has_active_animations() {
            if let Some(duration) = slint::platform::duration_until_next_timer_update() {
                // Sleep for at most the duration, but wake periodically for touch polling
                let sleep_ms = duration.as_millis().min(16) as u32; // Cap at ~60fps for touch
                esp_idf_hal::delay::FreeRtos::delay_ms(sleep_ms);
            } else {
                // No timers pending -- sleep briefly for touch responsiveness
                esp_idf_hal::delay::FreeRtos::delay_ms(16);
            }
        }
    }
}
