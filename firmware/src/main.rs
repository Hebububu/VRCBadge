mod display;
mod http;
mod platform;
mod touch;
mod wifi;

use std::cell::RefCell;

use esp_idf_hal::ledc::{config::TimerConfig, LedcDriver, LedcTimerDriver};
use esp_idf_hal::peripherals::Peripherals;
use esp_idf_hal::units::FromValueType;
use esp_idf_svc::eventloop::EspSystemEventLoop;
use esp_idf_svc::nvs::EspDefaultNvsPartition;
use esp_idf_sys as _;

use crate::display::DisplayLineBuffer;
use crate::platform::Esp32Platform;
use crate::touch::TouchController;

// Generated by slint-build from ui/badge.slint
slint::include_modules!();

fn main() -> anyhow::Result<()> {
    // Initialize ESP-IDF logging + system
    esp_idf_svc::log::EspLogger::initialize_default();
    log::info!("VRCBadge firmware starting (ESP32 port)");

    // Take hardware peripherals
    let peripherals = Peripherals::take()?;

    // --- WiFi AP + HTTP server ---
    let sys_loop = EspSystemEventLoop::take()?;
    let nvs_partition = EspDefaultNvsPartition::take()?;
    let _wifi = wifi::init(peripherals.modem, sys_loop, nvs_partition)?;
    let _server = http::init()?;

    // --- Slint platform ---
    let esp_platform = Esp32Platform::new();
    let window = esp_platform.window();
    slint::platform::set_platform(Box::new(esp_platform))
        .map_err(|e| anyhow::anyhow!("Failed to set Slint platform: {:?}", e))?;

    // --- Display (ST7796S over SPI) ---
    // ESP32 wiring: SCLK=18, MOSI=23, CS=5, DC=27, RST=33
    let mut display = display::init(
        peripherals.spi3,               // VSPI — native pins for GPIO 18/23/5
        peripherals.pins.gpio18.into(), // SCLK
        peripherals.pins.gpio23.into(), // MOSI
        peripherals.pins.gpio5.into(),  // CS
        peripherals.pins.gpio27.into(), // DC
        peripherals.pins.gpio33.into(), // RST
    )?;

    // --- Backlight PWM (25kHz, 8-bit = 256 duty levels) ---
    // ESP32 wiring: LCD_BL=32
    let timer = LedcTimerDriver::new(
        peripherals.ledc.timer0,
        &TimerConfig::new()
            .frequency(25.kHz().into())
            .resolution(esp_idf_hal::ledc::Resolution::Bits8),
    )?;
    let mut backlight = LedcDriver::new(peripherals.ledc.channel0, timer, peripherals.pins.gpio32)?;
    let max_duty = backlight.get_max_duty();
    backlight.set_duty(max_duty / 2)?; // Start at 50% brightness

    // --- Touch (GT911 over I2C) ---
    // ESP32 wiring: SDA=21, SCL=22, TP_RST=25
    let mut touch = TouchController::new(
        peripherals.i2c0,
        peripherals.pins.gpio21.into(), // SDA
        peripherals.pins.gpio22.into(), // SCL
        peripherals.pins.gpio25.into(), // Touch RST
    )?;

    // --- Create UI ---
    let ui = BadgeUI::new().map_err(|e| anyhow::anyhow!("Failed to create UI: {:?}", e))?;

    // Set initial values
    ui.set_display_name("Hebu".into());
    ui.set_tagline("Hello from VRCBadge!".into());
    ui.set_twitter_handle("@Hebu_VRC".into());
    ui.set_discord_handle("hebu".into());
    ui.set_battery_percent(100);

    // Wire brightness slider to backlight PWM
    let backlight = RefCell::new(backlight);
    ui.on_brightness_changed(move |percent| {
        let duty = (percent.clamp(10.0, 100.0) / 100.0 * max_duty as f32) as u32;
        let _ = backlight.borrow_mut().set_duty(duty);
    });

    log::info!("UI initialized, entering main loop");

    // --- Main event loop ---
    let mut loop_count: u32 = 0;
    loop {
        // 1. Process Slint timers and animations
        slint::platform::update_timers_and_animations();

        // 2. Poll touch input → dispatch events to Slint
        touch.poll(&window);

        // 3. Poll WiFi client count (~every 2 seconds at 16ms sleep = 125 iterations)
        loop_count = loop_count.wrapping_add(1);
        if loop_count % 125 == 0 {
            let clients = wifi::connected_clients() as i32;
            ui.set_wifi_clients(clients);
        }

        // 4. Render display if needed
        window.draw_if_needed(|renderer| {
            renderer.render_by_line(DisplayLineBuffer::new(&mut display));
        });

        // 5. Sleep until next event needed
        if !window.has_active_animations() {
            if let Some(duration) = slint::platform::duration_until_next_timer_update() {
                // Sleep for at most the duration, but wake periodically for touch polling
                let sleep_ms = duration.as_millis().min(16) as u32; // Cap at ~60fps for touch
                esp_idf_hal::delay::FreeRtos::delay_ms(sleep_ms);
            } else {
                // No timers pending — sleep briefly for touch responsiveness
                esp_idf_hal::delay::FreeRtos::delay_ms(16);
            }
        }
    }
}
